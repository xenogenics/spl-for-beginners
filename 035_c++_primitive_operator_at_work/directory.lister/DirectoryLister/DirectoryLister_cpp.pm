
package DirectoryLister_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print '/*', "\n";
   print '=====================================================', "\n";
   print 'This C++ primitive operator code does exactly the', "\n";
   print 'same logic done in the DirLister Java primitive', "\n";
   print 'operator that can be found in one of the SPL examples.', "\n";
   print '(samples/spl/feature/JavaOperators)', "\n";
   print '=====================================================', "\n";
   print '*/', "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{	', "\n";
   print '	// Let us parse the operator parameter named listDirectory.', "\n";
   print '	// This parameter may have zero or more input values.', "\n";
   print '	';
   		my $listDirectoryParam = $model->getParameterByName("listDirectory");
   		
   		if ($listDirectoryParam) {
   			my $numberOfParamValues = $listDirectoryParam->getNumberOfValues();
   			
   			for (my $cnt = 0; $cnt < $numberOfParamValues; $cnt++) {
   				print ("listDirectoryParam.push_back(" . $listDirectoryParam->getValueAt($cnt)->getSPLExpression() . ");\n");
   			} # End of for (my $cnt = 0; $cnt < $numberOfParamValues; $cnt++)
   		} # End of if (not $listDirectoryParam)
   	
   print "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '    /*', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '    */', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '    /*', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '          // do work ...', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '	// Define a output tuple variable.', "\n";
   print '	OPort0Type otuple;', "\n";
   print '	// Assign the values from the input tuple to the output tuple for all', "\n";
   print '	// the attributes that have the same name in both of those tuples.', "\n";
   print '	// Second parameter false in assignFrom method allows us to copy the ', "\n";
   print '	// attribute values between two tuples that are of different types (i.e. differ in their schema).', "\n";
   print '	otuple.assignFrom(tuple, false);', "\n";
   print '    ', "\n";
   print '	// Get the value of the first attribute which is called "name".', "\n";
   print '	// In this case, the "name" attribute carries the name of the Java property.', "\n";
   print '	// We can also get the tuple attribute values using the attribute position rather than the attribute names.', "\n";
   print '	ValueHandle handle0 = otuple.getAttributeValue(0);', "\n";
   print '	ustring const & dirPropertyName = handle0;', "\n";
   print '	', "\n";
   print '	// Convert the ustring to rstring.', "\n";
   print '	rstring dirPropertyName_rstring = SPL::ustring::toUTF8(dirPropertyName);', "\n";
   print '	', "\n";
   print '	// Check if this system property is in the group of directories from where the user wants to list files.', "\n";
   print '	// We have collected that user preferecnce in the constructor by reading the ', "\n";
   print '	// operator parameter named "listDirectory".', "\n";
   print '	std::vector<std::string>::iterator it;', "\n";
   print '	SPL::list<ustring> fileList;	', "\n";
   print '	', "\n";
   print '	it = std::find(listDirectoryParam.begin(), listDirectoryParam.end(), dirPropertyName_rstring);', "\n";
   print '		', "\n";
   print '	// If the name attribute is found in the group of directory names, let us find the files in that directory.', "\n";
   print '	if (it != listDirectoryParam.end()) {', "\n";
   print '		// Get the second attribute in the tuple that has the directory name.', "\n";
   print '		// That tuple attribute\'s name is "value".	', "\n";
   print '	    ValueHandle handle1 = otuple.getAttributeValue("value");', "\n";
   print '	    ustring const & dirName = handle1;', "\n";
   print '		// Convert it to rstring.', "\n";
   print '		rstring dirName_rstring = SPL::ustring::toUTF8(dirName);', "\n";
   print '		// Now, cast it to a regular std::string', "\n";
   print '		std::string & directoryName = static_cast<std::string &> (dirName_rstring);', "\n";
   print '		', "\n";
   print '		// Go and collect all the files in that directory.', "\n";
   print '		DIR *dp;', "\n";
   print '		struct dirent *dirp;', "\n";
   print '		', "\n";
   print '		if((dp  = opendir(directoryName.c_str())) != NULL) {', "\n";
   print '			while ((dirp = readdir(dp)) != NULL) {', "\n";
   print '				char const *d_name = dirp->d_name;', "\n";
   print '				fileList.push_back(SPL::ustring::fromUTF8(d_name));', "\n";
   print '			} // End of while ((dirp = readdir(dp)) != NULL)', "\n";
   print "\n";
   print '			closedir(dp);', "\n";
   print '		} // End of if((dp  = opendir(dirName.c_str())) != NULL)                                   ', "\n";
   print '	} // End of if (it != listDirectory.end())', "\n";
   print '	', "\n";
   print '	// If there are files found in the directory, let us add it to the ', "\n";
   print '	// "files" attribute of the output tuple (located at the very last position). ', "\n";
   print '	if (!fileList.empty()) {', "\n";
   print '		ValueHandle handle3 = otuple.getAttributeValue(3);', "\n";
   print '		List & list = handle3;', "\n";
   print '		SPL::list<ustring> & ustringList = static_cast<SPL::list<ustring> &> (list);', "\n";
   print '		ustringList = fileList;', "\n";
   print '	} // End of if (!fileList.empty())', "\n";
   print '	', "\n";
   print '	// Send this tuple away now.', "\n";
   print '	submit(otuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
