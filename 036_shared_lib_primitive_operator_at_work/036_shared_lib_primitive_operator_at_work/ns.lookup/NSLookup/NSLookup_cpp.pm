
package NSLookup_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print '#include <iostream>', "\n";
   print '#include "NameServerLookup.h"', "\n";
   print "\n";
   print 'using namespace primitive_operator_lib;', "\n";
   print 'using namespace std::tr1;', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '	// Initialize all the operator params to be true.', "\n";
   print '	// In this application, let us assume that we will return all the', "\n";
   print '	// four fields from the NS Lookup back to the caller.', "\n";
   print '	nameServerNameNeeded = true;', "\n";
   print '	nameServerAddessNeeded = true;', "\n";
   print '	clientMachineNameNeeded = true;', "\n";
   print '	clientMachineAddressNeeded = true;', "\n";
   print '	', "\n";
   print '	// Now, let us read the user preference that is passed via the operator parameters.', "\n";
   print '	';
   		my $nameServerNameNeededParam = $model->getParameterByName("nameServerNameNeeded");
   		my $nameServerAddressNeededParam = $model->getParameterByName("nameServerAddressNeeded");
   		my $clientMachineNameNeededParam = $model->getParameterByName("clientMachineNameNeeded");
   		my $clientMachineAddressNeededParam = $model->getParameterByName("clientMachineAddressNeeded");
   		 
   		if ($nameServerNameNeededParam) {
   			print ("nameServerNameNeeded = " . $nameServerNameNeededParam->getValueAt(0)->getCppExpression() . ";\n");
   		} # End of if ($nameServerNameNeededParam)
   		
   		if ($nameServerAddressNeededParam) {
   			print ("nameServerAddessNeeded = " . $nameServerAddressNeededParam->getValueAt(0)->getCppExpression() . ";\n");
   		} # End of if ($nameServerAddressNeededParam)
   		
   		if ($clientMachineNameNeededParam) {
   			print ("clientMachineNameNeeded = " . $clientMachineNameNeededParam->getValueAt(0)->getCppExpression() . ";\n");
   		} # End of if ($clientMachineNameNeededParam)		
   
   		if ($clientMachineAddressNeededParam) {
   			print ("clientMachineAddressNeeded = " . $clientMachineAddressNeededParam->getValueAt(0)->getCppExpression() . ";\n");
   		} # End of if ($clientMachineAddressNeededParam)				
   	
   print "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '    /*', "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '    */', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '    /*', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '          // do work ...', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '	// Define a output tuple variable.', "\n";
   print '	OPort0Type otuple;', "\n";
   print '	// Assign the values from the input tuple to the output tuple for all', "\n";
   print '	// the attributes that have the same name in both of those tuples.', "\n";
   print '	// Second parameter false in assignFrom method allows us to copy the ', "\n";
   print '	// attribute values between two tuples that are of different types (i.e. differ in their schema).', "\n";
   print '	otuple.assignFrom(tuple, false);   ', "\n";
   print '    ', "\n";
   print '	// Get the value of the first attribute in the output tuple which is called "nodeName".', "\n";
   print '	// In this case, the "nodeName" attribute carries the name of the node for which', "\n";
   print '	// we want to do the NSLookup.', "\n";
   print '	// We can also get the tuple attribute values using the attribute position rather than the attribute names.', "\n";
   print '	ValueHandle handle0 = otuple.getAttributeValue(0);', "\n";
   print '	rstring const & nodeName_rstring = handle0;', "\n";
   print '	std::string const & nodeName = nodeName_rstring.string();', "\n";
   print '	', "\n";
   print '	// We can now invoke the NSLookup method from the class located inside the shared library.', "\n";
   print '	NameServerLookup nsl;', "\n";
   print '	', "\n";
   print '	/*', "\n";
   print '	// We could do the following to get the result from unordered_map to an SPL::map.', "\n";
   print '	// But, it requires some extra work.', "\n";
   print '	std::tr1::unordered_map<std::string,std::string> const & result = nsl.getNSLookupResults(nodeName);', "\n";
   print '	SPL::map<rstring, rstring> resultMap;', "\n";
   print '	resultMap.insert(result.begin(), result.end());', "\n";
   print '	*/', "\n";
   print '	', "\n";
   print '	unordered_map<std::string, std::string> resultMap = nsl.getNSLookupResults(nodeName);', "\n";
   print '	int32 resultMapSize = resultMap.size();', "\n";
   print '	', "\n";
   print '	// If we have 4 elements returned in the resultMap, then we can assign ', "\n";
   print '	// the values to the output tuple attributes.', "\n";
   print '	if (resultMapSize == 4) {	 	', "\n";
   print '		// If we need to assign this attribute, let us do that now.', "\n";
   print '		if (nameServerNameNeeded == true) {', "\n";
   print '			ValueHandle handle1 = otuple.getAttributeValue(1);', "\n";
   print '			rstring & nameServerName = handle1;', "\n";
   print '			nameServerName = resultMap["Name Server Name"];', "\n";
   print '		} // End of if (nameServerNameNeeded == true)', "\n";
   print '				', "\n";
   print '		// If we need to assign this attribute, let us do that now.', "\n";
   print '		if (nameServerAddessNeeded == true) {', "\n";
   print '			ValueHandle handle2 = otuple.getAttributeValue(2);', "\n";
   print '			rstring & nameServerAddess = handle2;', "\n";
   print '			nameServerAddess = resultMap["Name Server Address"];', "\n";
   print '		} // End of if (nameServerAddessNeeded == true)		', "\n";
   print "\n";
   print '		// If we need to assign this attribute, let us do that now.', "\n";
   print '		if (clientMachineNameNeeded == true) {', "\n";
   print '			ValueHandle handle3 = otuple.getAttributeValue(3);', "\n";
   print '			rstring & clientMachineName = handle3;', "\n";
   print '			clientMachineName = resultMap["Client Machine Name"];', "\n";
   print '		} // End of if (clientMachineNameNeeded == true)	', "\n";
   print "\n";
   print '		// If we need to assign this attribute, let us do that now.', "\n";
   print '		if (clientMachineAddressNeeded == true) {', "\n";
   print '			ValueHandle handle4 = otuple.getAttributeValue(4);', "\n";
   print '			rstring & clientMachineAddress = handle4;', "\n";
   print '			clientMachineAddress = resultMap["Client Machine Address"];', "\n";
   print '		} // End of if (clientMachineAddressNeeded == true)		', "\n";
   print '	} // End of if (resultMapSize == 4)', "\n";
   print '	', "\n";
   print '	// Send this tuple away now.', "\n";
   print '	submit(otuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
