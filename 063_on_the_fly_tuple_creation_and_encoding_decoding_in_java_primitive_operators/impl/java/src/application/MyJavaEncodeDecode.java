/* Generated by Streams Studio: September 22, 2013 7:55:47 AM EDT */
/*
This Java primitive operator is an example to show how new tuples can be
created on the fly in Java. Then, it also shows how to encode tuple contents
into a byte buffer and then decode byte buffer contents into a tuple.
These three techniques will come handy in certain application scenarios. 
*/
package application;

import org.apache.log4j.Logger;

import com.ibm.streams.operator.*;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.encoding.*;
import com.ibm.streams.operator.meta.CollectionType;
import com.ibm.streams.operator.meta.TupleType;
import com.ibm.streams.operator.types.*;

import java.util.Map;
import java.util.HashMap;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.ArrayList;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple. 
 * This pattern supports a number of input streams and a single output stream. 
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>process() handles a tuple arriving on an input port 
 * <li>processPuncuation() handles a punctuation mark arriving on an input port 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
public class MyJavaEncodeDecode extends AbstractOperator {
	
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
    	// This method is commonly used by source operators. 
    	// Operators that process incoming tuples generally do not need this notification. 
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port. 
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple)
            throws Exception {

    	// Create a new tuple for output port 0
        StreamingOutput<OutputTuple> outStream = getOutput(0);
        OutputTuple outTuple = outStream.newTuple();

        // Copy across all matching attributes.
        outTuple.assign(tuple);

        // TODO: Insert code to perform transformation on output tuple as needed:
        // outTuple.setString("AttributeName", "AttributeValue");

        // Create a new tuple on the fly using the SPL type declaration syntax.
        // Important tip: In the tuple declaration, note that there is no space between key and value of map.
        // If you have spaces in between, then the following statement will not work.
        TupleType tt = Type.Factory.getTupleType("tuple<int32 x, uint64 y, float32 z, list<float64> prices, map<rstring,rstring> companyInfo>");
        // Get a schema for the newly created tuple type above.
        StreamSchema ss1 = tt.getTupleSchema();

        // Get a map to fill our new tuple type contents.
        Map<String, Object> attrMap1 = new HashMap<String, Object>();
        // Get the values ready to be assigned to the tuple attributes.
        // Do a google search for "Working with SPL types". In the resulting page,
        // refer to tables 1 and 2 to learn about SPL to Java type mappings.
        java.lang.Integer _x = new java.lang.Integer(5);
        java.lang.Long _y = new java.lang.Long(766464564564564l);
        java.lang.Float _z = new java.lang.Float(3.14);
        double[] _p = new double[3];
        _p[0] = 76.34;
        _p[1] = 33.35;
        _p[2] = 76.28;                
        Map<RString, RString> _c = new HashMap<RString, RString>();		
		_c.put(new RString("HD"), new RString("Home Goods Giant"));
		_c.put(new RString("GM"), new RString("Auto Giant"));
		_c.put(new RString("WMT"), new RString("Retail Giant"));
        
        // Populate the tuple attributes with correct values.
		attrMap1.put("x", _x);
		attrMap1.put("y", _y);
		attrMap1.put("z", _z);
		attrMap1.put("prices", _p);
		attrMap1.put("companyInfo", _c);
		
		// Using the attribute map created above, create a new concrete tuple on the fly.
		Tuple ssTuple1 = ss1.getTuple(attrMap1);
		System.out.println("New Tuple=" + ssTuple1);
		
		// Convert the tuple into a blob.
        BinaryEncoding be = ss1.newNativeBinaryEncoding();
        // Get the maximum number of bytes required to encode our tuple.
        long requiredBufferSize = be.getEncodedSize(ssTuple1);
        ByteBuffer byteBuffer = ByteBuffer.allocate((int)requiredBufferSize);
        System.out.println("Required buffer size=" + requiredBufferSize);
        System.out.println("Buffer remaining before encoding=" + byteBuffer.remaining());
        // Encode our tuple into a blob now.
        be.encodeTuple(ssTuple1, byteBuffer);
        System.out.println("Buffer remaining after encoding=" + byteBuffer.remaining());
        System.out.println("Actual encoded buffer size=" + byteBuffer.position());
        System.out.println("Encoded buffer contents=" + byteBuffer);
        // Set the buffer to its beginning.
        byteBuffer.rewind();
        
        // Decode the (blob) byte buffer into a tuple now.
        BinaryEncoding be2 = ss1.newNativeBinaryEncoding();
        Tuple myTuple = be2.decodeTuple(byteBuffer);
        System.out.println("Decoded tuple=" + myTuple);   
        System.out.println("myTuple.x=" + myTuple.getInt("x"));
        System.out.println("myTuple.y=" + myTuple.getLong("y"));
        System.out.println("myTuple.z=" + myTuple.getFloat("z"));
        System.out.println("myTuple.prices=" + myTuple.getList("prices"));
        System.out.println("myTuple.companyInfo=" + myTuple.getMap("companyInfo"));
        // Submit new tuple to output port 0
        outStream.submit(outTuple);
    }
    
    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    	// For window markers, punctuate all output ports 
    	super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }
}
