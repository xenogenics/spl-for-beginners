/* Generated by Streams Studio: August 27, 2014 2:28:31 PM EDT */
/*
In this Java primitive operator, we are demonstrating the following three features.

1) Invoking a Java operator with operator parameters in the param clause.
2) Processing tuples inside a Java operator arriving from multiple input ports.
3) As a bonus, it shows a way to populate a complex output tuple containing other nested tuple structures.
*/

package com.acme.test;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamSchema;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.meta.CollectionType;
import com.ibm.streams.operator.meta.TupleType;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.ibm.streams.operator.types.RString;

/**
 * Class for an operator that receives a tuple and then optionally submits a tuple. 
 * This pattern supports one or more input streams and one or more output streams. 
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to process and submit tuples</li> 
 * <li>process() handles a tuple arriving on an input port 
 * <li>processPuncuation() handles a punctuation mark arriving on an input port 
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any time, 
 * such as a request to stop a PE or cancel a job. 
 * Thus the shutdown() may occur while the operator is processing tuples, punctuation marks, 
 * or even during port ready notification.</li>
 * </ul>
 * <p>With the exception of operator initialization, all the other events may occur concurrently with each other, 
 * which lead to these methods being called concurrently by different threads.</p> 
 */
@PrimitiveOperator(name="MyJavaOp", namespace="com.acme.test",
description="Java Operator MyJavaOp")
@InputPorts({@InputPortSet(description="Port that ingests tuples", cardinality=1, optional=false, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious), @InputPortSet(description="Optional input ports", optional=true, windowingMode=WindowMode.NonWindowed, windowPunctuationInputMode=WindowPunctuationInputMode.Oblivious)})
@OutputPorts({@OutputPortSet(description="Port that produces tuples", cardinality=1, optional=false, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating), @OutputPortSet(description="Optional output ports", optional=true, windowPunctuationOutputMode=WindowPunctuationOutputMode.Generating)})
public class MyJavaOp extends AbstractOperator {
	// Let us declare two member variables that will be later assigned with the values passed via
	// the operator parameters in the SPL file at the time of the operator invocation.
	// We will have some initial default values.
	private float floatVal = 0.0f;
	private int intVal = 5;	
	
    /**
     * Initialize this operator. Called once before any tuples are processed.
     * @param context OperatorContext for this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {
    	// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " initializing in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO:
        // If needed, insert code to establish connections or resources to communicate an external system or data store.
        // The configuration information for this may come from parameters supplied to the operator invocation, 
        // or external configuration files or a combination of the two.
	}

    /**
     * Notification that initialization is complete and all input and output ports 
     * are connected and ready to receive and submit tuples.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public synchronized void allPortsReady() throws Exception {
    	// This method is commonly used by source operators. 
    	// Operators that process incoming tuples generally do not need this notification. 
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " all ports are ready in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
    }

    /**
     * Process an incoming tuple that arrived on the specified port.
     * <P>
     * Copy the incoming tuple to a new output tuple and submit to the output port. 
     * </P>
     * @param inputStream Port the tuple is arriving on.
     * @param tuple Object representing the incoming tuple.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public final void process(StreamingInput<Tuple> inputStream, Tuple tuple)
            throws Exception {
    	// In this Java operator, we have 3 input streams and three output streams.
    	// When tuples arrive, we have to process them selectively depending on which input port they come from.
    	// We can use the following API to determine the input port number.
    	if (inputStream.getPortNumber() == 0) {	
	    	// Create a new tuple for output port 0
	        StreamingOutput<OutputTuple> outStream = getOutput(0);
	        OutputTuple outTuple = outStream.newTuple();
	
	        // Copy across all matching attributes.
	        outTuple.assign(tuple);
	
	        // TODO: Insert code to perform transformation on output tuple as needed:
	        outTuple.setInt("i", intVal);
	
	        // Submit new tuple to output port 0
	        outStream.submit(outTuple);
    	} else if (inputStream.getPortNumber() == 1) {	
	    	// Create a new tuple for output port 1
	        StreamingOutput<OutputTuple> outStream = getOutput(1);
	        OutputTuple outTuple = outStream.newTuple();
	
	        // Copy across all matching attributes.
	        outTuple.assign(tuple);
	
	        // TODO: Insert code to perform transformation on output tuple as needed:
	        outTuple.setFloat("f", floatVal);
	
	        // Submit new tuple to output port 1
	        outStream.submit(outTuple);
    	} else if (inputStream.getPortNumber() == 2) {
    		// For this incoming stream on port 3, we are going to show how we can populate
    		// our 3rd output stream with complex tuples that are nested to several levels of depth.
    		// [Please note that in a completely different example (053_java_primitive_operator_with_complex_output_tuple_types), we demonstrated a different
    		//  mechanism to populate output tuples with complex types. In this particular Java operator here
    		//  we are showing another way to do the same which is a lot better approach.]
    		//
    		// This shows how to do on the fly creation of output tuples that contain nested (complex) types such as SPL lists and other SPL tuples.
    		//
    		// We have to generate an output tuple that will conform to the following schema defined in the SPL file.
    		// CrewDutyTimeType = CrewInfoType, tuple<int32 dutyTimeMinutes>;
    		// CrewInfoType = tuple<rstring employeeNumber, rstring firstName, rstring lastName, rstring middleInitial, rstring crewBase, list<CrewSequenceType> sequences>;
    		// CrewSequenceType = tuple<boolean isDomestic, rstring sequencePosition, rstring sequenceKey, rstring originDate, list<CrewDutyPeriodType> dutyPeriods>;
    		// CrewDutyPeriodType = tuple<rstring dutyPeriodStartDateGMT, rstring dutyPeriodEndDateGMT, list<FlightPairingType> pairings>;
    		// FlightPairingType = tuple<rstring flightNumber, rstring originAirport, rstring destinationAirport>;    		

    		// Get an output stream object suitable for output port 2.
    		StreamingOutput<OutputTuple> output = getOutput(2);

    		// Get the type of the "sequences" output tuple attribute and cast it to CollectionType since it an SPL list type.
    		CollectionType sequencesType = (CollectionType) output.getStreamSchema().getAttribute("sequences").getType();
    		// Get a concrete tuple type by casting it properly to TupleType.
    		TupleType sequencesTupleType = (TupleType) sequencesType.getElementType();
    		// Get the stream schema for the top level sequences attribute.
    		StreamSchema sequencesSchema = sequencesTupleType.getTupleSchema();
    		// System.out.println("sequences schema = " + sequencesSchema);
    	        
    		// Get the stream schema for the nested dutyPeriods attribute that is contained inside the sequencesSchema.
    		CollectionType dutyPeriodsType = (CollectionType) sequencesSchema.getAttribute("dutyPeriods").getType();
    		TupleType dutyPeriodsTupleType = (TupleType) dutyPeriodsType.getElementType();
    		StreamSchema dutyPeriodsSchema = dutyPeriodsTupleType.getTupleSchema();
    		// System.out.println("dutyPeriods schema = " + dutyPeriodsSchema);
    	        
    		// Get the stream schema for the nested pairings attribute that is contained inside the dutyPeriodsSchema.
    		CollectionType pairingsType = (CollectionType) dutyPeriodsSchema.getAttribute("pairings").getType();
    		TupleType pairingsTupleType = (TupleType) pairingsType.getElementType();
    		StreamSchema pairingsSchema = pairingsTupleType.getTupleSchema();   
    		// System.out.println("pairings schema = " + pairingsSchema);
    	        
    		// Create a Java list to hold the tuples made of CrewSequenceType.
    		List<Tuple> _sequences = new ArrayList<Tuple>();
    		// Get a map to stuff all the attributes belonging to CrewSequenceType.
    		Map<String, Object> _attrMap = new HashMap<String, Object>();		
    			
    		// Fill the attribute map.
    		RString originDate = new RString("OriginDate1");
    		RString sequenceKey = new RString("SequenceKey1");
    		RString sequencePosition = new RString("SequencePosition1");
    		boolean isDomestic = true;
    	       
    		_attrMap.put("originDate", originDate);
    		_attrMap.put("sequenceKey", sequenceKey);
    		_attrMap.put("sequencePosition", sequencePosition);
    		_attrMap.put("isDomestic", isDomestic);
    	        
    		// Create a Java list to hold the tuples made of CrewDutyPeriodType.
    		List<Tuple> _dutyPeriods = new ArrayList<Tuple>();
    		// Get a map and fill out new tuple type contents for crew duty period.
    		Map<String, Object> attrMap1 = new HashMap<String, Object>();
    		attrMap1.put("dutyPeriodStartDateGMT", new RString("dutyPeriodStartDateGMT1"));
    		attrMap1.put("dutyPeriodEndDateGMT", new RString("dutyPeriodEndDateGMT"));
    	        
    		// Create a Java list to hold the tuples made of FlightPairingType.
    		List<Tuple> _pairings = new ArrayList<Tuple>();
    		// Get a map and fill out new tuple type contents for flight pairing type.
    		Map<String, Object> attrMap2 = new HashMap<String, Object>();
    		attrMap2.put("flightNumber", new RString("flightNumber1"));
    		attrMap2.put("originAirport", new RString("originAirport1"));
    		attrMap2.put("destinationAirport", new RString("destinationAirport1"));
    		Tuple _pairingsTuple = pairingsSchema.getTuple(attrMap2);
    		_pairings.add(_pairingsTuple);

    		// Add the pairings to attrMap1.
    		attrMap1.put("pairings", _pairings);
    	        
    		// Get a new tuple object for the dutyPeriods that is made of the CrewDutyPeriodType SPL type.
    		Tuple _dutyPeriodsTuple = dutyPeriodsSchema.getTuple(attrMap1);
    		// Add the dutyPeriods tuple to the list<CrewDutyPeriodType>
    		_dutyPeriods.add(_dutyPeriodsTuple);
    		// Now add the _dutyPeriods list to the _sequences attribute map.
    		_attrMap.put("dutyPeriods", _dutyPeriods);
    	        
    		// We finished populating all the attributes belonging to the CrewSequenceType.
    		// Get a new tuple object for the sequences that is made of the CrewSequenceType SPL type.
    		Tuple _sequencesTuple = sequencesSchema.getTuple(_attrMap);
    		// Now add the _sequences tuple to the list<CrewSequenceType>
    		_sequences.add(_sequencesTuple);
    	        
    		// Create a new final output tuple, set all its attributes and  send it out on output port 0.
    		OutputTuple outputTuple = output.newTuple();
    		outputTuple.setString("employeeNumber", "employeeNumber1");
    		outputTuple.setString("firstName", "firstName1");
    		outputTuple.setString("lastName", "lastName1");
    		outputTuple.setString("middleInitial", "middleInitial1");
    		outputTuple.setString("crewBase", "crewBase1");
    		outputTuple.setList("sequences", _sequences);
    		outputTuple.setInt("dutyTimeMinutes", 234);
    	        
    		// Send this tuple away now.
    		try {
    			output.submit(outputTuple);
    		} catch (Exception ex) {
    			ex.printStackTrace();
    		} // End of try-catch block.
    	}    	
    }
    
    /**
     * Process an incoming punctuation that arrived on the specified port.
     * @param stream Port the punctuation is arriving on.
     * @param mark The punctuation mark
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    @Override
    public void processPunctuation(StreamingInput<Tuple> stream,
    		Punctuation mark) throws Exception {
    	// For window markers, punctuate all output ports 
    	super.processPunctuation(stream, mark);
    }

    /**
     * Shutdown this operator.
     * @throws Exception Operator failure, will cause the enclosing PE to terminate.
     */
    public synchronized void shutdown() throws Exception {
        OperatorContext context = getOperatorContext();
        Logger.getLogger(this.getClass()).trace("Operator " + context.getName() + " shutting down in PE: " + context.getPE().getPEId() + " in Job: " + context.getPE().getJobId() );
        
        // TODO: If needed, close connections or release resources related to any external system or data store.

        // Must call super.shutdown()
        super.shutdown();
    }
    
    // In order to pass Java operator parameters, we can use the following @Parameter annotation.
    // name should be the actual parameter name and it can be set as a mandatory or an optional parameter.
    @Parameter(name="floatVal", optional=true)
    public void setFloatVal(float f) {
    	// Assign the parameter value to a member variable.
    	this.floatVal = f;
    }
    
    @Parameter(name="intVal", optional=false)
    public void setIntVal(int i) {
    	this.intVal = i;
    }        
}
