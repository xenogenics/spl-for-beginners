
package SimpleSourceOp_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
   print '// To support the consistent regions, this operator must do this check.', "\n";
      my $isInConsistentRegion = $model->getContext()->getOptionalContext("ConsistentRegion");
   print "\n";
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR() : serialNumber(0), productId(100), productName(""), quantity(10)', "\n";
   print '{', "\n";
   print '	// This operator must do this registration needed for consistent regions.', "\n";
   print '    ';
   if ($isInConsistentRegion) {
   print "\n";
   print '      getContext().registerStateHandler(*this);', "\n";
   print '    ';
   }
   print "\n";
   print '    ', "\n";
   print '   serialNumber = 0;', "\n";
   print '   productId = 100;', "\n";
   print '   productName = "";', "\n";
   print '   quantity = 10;     ', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '    // Notifies that all ports are ready. No tuples should be submitted before', "\n";
   print '    // this. Source operators can use this method to spawn threads.', "\n";
   print "\n";
   print '      createThreads(1); // Create source thread', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '	// Do an init delay of 4 seconds for other operators to get connected.', "\n";
   print '	sleep(4);', "\n";
   print '	', "\n";
   print '    // A typical implementation will loop until shutdown', "\n";
   print '      while(!getPE().getShutdownRequested()) {', "\n";
   print '    	// Let us update our internal state.', "\n";
   print '    	// Then, submit our tuple.', "\n";
   print '    	AutoPortMutex am(myMutex, *this);', "\n";
   print '    	', "\n";
   print '    	// Sleep a second before submitting each tuple.', "\n";
   print '    	sleep(1);', "\n";
   print '    	', "\n";
   print '    	// Don\'t submit more than 100 tuples since it is only a very simple test.', "\n";
   print '    	if (serialNumber >= 100) {', "\n";
   print '    		continue;', "\n";
   print '        }', "\n";
   print '    	', "\n";
   print '    	OPort0Type oTuple;', "\n";
   print '    	ValueHandle handle0 = oTuple.getAttributeValue(0);', "\n";
   print '		int32_t & _serialNumber = handle0;', "\n";
   print '		_serialNumber = ++serialNumber;', "\n";
   print '    	', "\n";
   print '    	ValueHandle handle1 = oTuple.getAttributeValue(1);', "\n";
   print '    	int32_t & _productId = handle1;', "\n";
   print '    	_productId = ++productId;    ', "\n";
   print '    	', "\n";
   print '    	ValueHandle handle2 = oTuple.getAttributeValue(2);', "\n";
   print '    	std::string & _productName = handle2;', "\n";
   print '    	char productNameBuffer[200];', "\n";
   print '    	sprintf(productNameBuffer, "%d", productId);', "\n";
   print '    	_productName = "Product" + std::string(productNameBuffer);', "\n";
   print '    	', "\n";
   print '    	ValueHandle handle3 = oTuple.getAttributeValue(3);', "\n";
   print '    	int32_t & _quantity = handle3;', "\n";
   print '    	_quantity = ++quantity;', "\n";
   print '    	', "\n";
   print '    	// Send this tuple away.', "\n";
   print '    	submit(oTuple, 0);	', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print '// To support the consistent regions, this operator must implement the following methods.', "\n";
   if ($isInConsistentRegion) {
   print "\n";
   print '// Persist state to shared file system', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::checkpoint(Checkpoint & ckpt)', "\n";
   print '{', "\n";
   print '	// cout << "Performing a checkpoint." << endl;', "\n";
   print '    ckpt << serialNumber << productId << productName << quantity << "\\n";', "\n";
   print '}', "\n";
   print "\n";
   print '// Restore state from shared file system', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::reset(Checkpoint & ckpt)', "\n";
   print '{', "\n";
   print '	// cout << "Performing a reset." << endl;', "\n";
   print '    ckpt >> serialNumber >> productId >> productName >> quantity;', "\n";
   print '}', "\n";
   print "\n";
   print '// Sets operator state to its initial state', "\n";
   print '// This is needed only when there is a crash anywhere in the application before the', "\n";
   print '// very first checkpoint is done.', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::resetToInitialState()', "\n";
   print '{', "\n";
   print '   // cout << "Performing a resetToInitialState." << endl;', "\n";
   print '   serialNumber = 0;', "\n";
   print '   productId = 100;', "\n";
   print '   productName = "";', "\n";
   print '   quantity = 10;    ', "\n";
   print '}', "\n";
   }
   print "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
